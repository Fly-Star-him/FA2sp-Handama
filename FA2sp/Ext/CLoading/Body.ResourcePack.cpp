#include "Body.h"
#include <openssl/aes.h>
#include <cstring>

namespace EncryptionKey
{
    // *************** Please cover the following codes with codes generated by key_obf.py *************** //
    // ***************    This is an example of password Dt!5OoxWyIHsh#p~s6LKOmEeRJI44!AW  *************** //
    // ***************      DO NOT USE THIS PASSWORD & CODE IN PRODUCTION ENVIRONMENTS     *************** //

    unsigned char* f00() {
        static unsigned char part[4];
        unsigned char v00 = static_cast<unsigned char>(232 ^ 144 ^ 60);
        part[0] = v00;
        unsigned char v01 = static_cast<unsigned char>(42 ^ 3 ^ 118 ^ 207 ^ 178 ^ 86);
        part[1] = v01;
        unsigned char v02 = static_cast<unsigned char>(17 ^ 130 ^ 251 ^ 237 ^ 169 ^ 13);
        part[2] = v02;
        unsigned char v03 = static_cast<unsigned char>(186 ^ 80 ^ 223);
        part[3] = v03;
        return part;
    }

    unsigned char* f01() {
        static unsigned char part[4];
        unsigned char v04 = static_cast<unsigned char>(36 ^ 108 ^ 239 ^ 65 ^ 43 ^ 130);
        part[0] = v04;
        unsigned char v05 = static_cast<unsigned char>(133 ^ 188 ^ 33 ^ 141 ^ 250);
        part[1] = v05;
        unsigned char v06 = static_cast<unsigned char>(37 ^ 72 ^ 81 ^ 108 ^ 40);
        part[2] = v06;
        unsigned char v07 = static_cast<unsigned char>(157 ^ 100 ^ 143 ^ 33);
        part[3] = v07;
        return part;
    }

    unsigned char* f02() {
        static unsigned char part[4];
        unsigned char v08 = static_cast<unsigned char>(47 ^ 233 ^ 1 ^ 242 ^ 76);
        part[0] = v08;
        unsigned char v09 = static_cast<unsigned char>(137 ^ 147 ^ 2 ^ 255 ^ 64 ^ 238);
        part[1] = v09;
        unsigned char v0a = static_cast<unsigned char>(117 ^ 215 ^ 170 ^ 161 ^ 225);
        part[2] = v0a;
        unsigned char v0b = static_cast<unsigned char>(221 ^ 182 ^ 55 ^ 47);
        part[3] = v0b;
        return part;
    }

    unsigned char* f03() {
        static unsigned char part[4];
        unsigned char v0c = static_cast<unsigned char>(208 ^ 17 ^ 169);
        part[0] = v0c;
        unsigned char v0d = static_cast<unsigned char>(44 ^ 15 ^ 116 ^ 73 ^ 117 ^ 72);
        part[1] = v0d;
        unsigned char v0e = static_cast<unsigned char>(234 ^ 15 ^ 149);
        part[2] = v0e;
        unsigned char v0f = static_cast<unsigned char>(170 ^ 158 ^ 223 ^ 149);
        part[3] = v0f;
        return part;
    }

    unsigned char* f04() {
        static unsigned char part[4];
        unsigned char v10 = static_cast<unsigned char>(141 ^ 45 ^ 51 ^ 91 ^ 187);
        part[0] = v10;
        unsigned char v11 = static_cast<unsigned char>(123 ^ 199 ^ 157 ^ 17 ^ 6);
        part[1] = v11;
        unsigned char v12 = static_cast<unsigned char>(35 ^ 72 ^ 39);
        part[2] = v12;
        unsigned char v13 = static_cast<unsigned char>(245 ^ 178 ^ 21 ^ 25);
        part[3] = v13;
        return part;
    }

    unsigned char* f05() {
        static unsigned char part[4];
        unsigned char v14 = static_cast<unsigned char>(56 ^ 222 ^ 218 ^ 170 ^ 19 ^ 202);
        part[0] = v14;
        unsigned char v15 = static_cast<unsigned char>(21 ^ 191 ^ 165 ^ 151 ^ 245);
        part[1] = v15;
        unsigned char v16 = static_cast<unsigned char>(244 ^ 173 ^ 71 ^ 103 ^ 93 ^ 97);
        part[2] = v16;
        unsigned char v17 = static_cast<unsigned char>(195 ^ 126 ^ 36 ^ 252);
        part[3] = v17;
        return part;
    }

    unsigned char* f06() {
        static unsigned char part[4];
        unsigned char v18 = static_cast<unsigned char>(128 ^ 86 ^ 132);
        part[0] = v18;
        unsigned char v19 = static_cast<unsigned char>(201 ^ 81 ^ 210);
        part[1] = v19;
        unsigned char v1a = static_cast<unsigned char>(171 ^ 182 ^ 237 ^ 254 ^ 151 ^ 208);
        part[2] = v1a;
        unsigned char v1b = static_cast<unsigned char>(230 ^ 138 ^ 88);
        part[3] = v1b;
        return part;
    }

    unsigned char* f07() {
        static unsigned char part[4];
        unsigned char v1c = static_cast<unsigned char>(248 ^ 26 ^ 214);
        part[0] = v1c;
        unsigned char v1d = static_cast<unsigned char>(117 ^ 235 ^ 191);
        part[1] = v1d;
        unsigned char v1e = static_cast<unsigned char>(117 ^ 228 ^ 158 ^ 89 ^ 23);
        part[2] = v1e;
        unsigned char v1f = static_cast<unsigned char>(225 ^ 24 ^ 209 ^ 122 ^ 5);
        part[3] = v1f;
        return part;
    }

    // ***************                 This is the end of the covered area                 *************** //
}

using namespace EncryptionKey;
std::array<uint8_t, 32> ResourcePack::get_aes_key()
{
    std::array<uint8_t, 32> key = {};
    unsigned char* seg;

    seg = f00(); for (int i = 0; i < 4; ++i) key[i] = seg[i];
    seg = f01(); for (int i = 0; i < 4; ++i) key[4 + i] = seg[i];
    seg = f02(); for (int i = 0; i < 4; ++i) key[8 + i] = seg[i];
    seg = f03(); for (int i = 0; i < 4; ++i) key[12 + i] = seg[i];
    seg = f04(); for (int i = 0; i < 4; ++i) key[16 + i] = seg[i];
    seg = f05(); for (int i = 0; i < 4; ++i) key[20 + i] = seg[i];
    seg = f06(); for (int i = 0; i < 4; ++i) key[24 + i] = seg[i];
    seg = f07(); for (int i = 0; i < 4; ++i) key[28 + i] = seg[i];

    return key;
}

bool ResourcePack::load(const std::string& filename) 
{
    file_path = filename;
    file_stream.open(filename, std::ios::binary | std::ios::ate);
    if (!file_stream) return false;

    std::streamsize total_size = file_stream.tellg();
    file_stream.seekg(0);
    file_buffer.resize(static_cast<size_t>(total_size));
    file_stream.read(reinterpret_cast<char*>(file_buffer.data()), total_size);

    if (memcmp(file_buffer.data(), "RPCK", 4) != 0) return false;

    index_size = *reinterpret_cast<uint32_t*>(&file_buffer[4]);

    if (index_size == 0 || 8 + index_size > file_buffer.size()) return false;

    std::vector<uint8_t> decrypted_index;
    if (!aesDecryptBlockwise(file_buffer.data() + 8, index_size, decrypted_index)) {
        return false;
    }
    size_t offset = 0;
    while (offset + 256 + 12 <= decrypted_index.size()) {
        std::string name(reinterpret_cast<char*>(&decrypted_index[offset]), 256);
        name = name.c_str(); 

        offset += 256;

        FileEntry entry;
        memcpy(&entry, &decrypted_index[offset], sizeof(FileEntry));
        offset += sizeof(FileEntry);

        if (8 + index_size + entry.offset + entry.enc_size > file_buffer.size()) {
            return false;
        }

        // file size can not over 200MB
        if (entry.enc_size == 0 || entry.enc_size > (200 << 20)) {
            return false;
        }

        index_map[name] = entry;
    }

    return true;
}

bool ResourcePack::aesDecryptBlockwise(const uint8_t* input, size_t len, std::vector<uint8_t>& output) 
{
    if (len % AES_BLOCK_SIZE != 0) return false;

    output.resize(len);
    AES_KEY aes;
    AES_set_decrypt_key(get_aes_key().data(), 256, &aes);

    uint8_t iv[AES_BLOCK_SIZE] = { 0 };
    AES_cbc_encrypt(input, output.data(), len, &aes, iv, AES_DECRYPT);

    return true;
}

std::unique_ptr<uint8_t[]> ResourcePack::getFileData(const std::string& filename, size_t* out_size)
{
    auto it = index_map.find(filename);
    if (it == index_map.end()) return nullptr;

    const FileEntry& entry = it->second;

    size_t data_offset = 8 + index_size + entry.offset;
    if (data_offset + entry.enc_size > file_buffer.size()) return nullptr;

    const uint8_t* encrypted_data = &file_buffer[data_offset];

    std::unique_ptr<uint8_t[]> decrypted_data(new uint8_t[entry.enc_size]);

    AES_KEY aes;
    AES_set_decrypt_key(get_aes_key().data(), 256, &aes);

    uint8_t iv[AES_BLOCK_SIZE] = { 0 };
    AES_cbc_encrypt(encrypted_data, decrypted_data.get(), entry.enc_size, &aes, iv, AES_DECRYPT);

    if (out_size)
        *out_size = entry.original_size;

    std::unique_ptr<uint8_t[]> result(new uint8_t[entry.original_size]);
    memcpy(result.get(), decrypted_data.get(), entry.original_size);
    return result;
}

ResourcePackManager& ResourcePackManager::instance() 
{
    static ResourcePackManager mgr;
    return mgr;
}

bool ResourcePackManager::loadPack(const std::string& packPath) 
{
    auto pack = std::make_unique<ResourcePack>();
    if (pack->load(packPath)) {
        packs.push_back(std::move(pack));
        return true;
    }
    return false;
}

std::unique_ptr<uint8_t[]> ResourcePackManager::getFileData(const std::string& filename, size_t* out_size) 
{
    for (auto& pack : packs) {
        auto data = pack->getFileData(filename, out_size);
        if (data) return data;
    }
    return nullptr;
}

void ResourcePackManager::clear() 
{
    packs.clear();
}